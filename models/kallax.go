// Code generated by https://github.com/src-d/go-kallax. DO NOT EDIT.
// Please, do not touch the code below, and if you do, do it under your own
// risk. Take into account that all the code you write here will be completely
// erased from earth the next time you generate the kallax models.
package models

import (
	"database/sql"
	"fmt"

	"gopkg.in/src-d/go-kallax.v1"
	"gopkg.in/src-d/go-kallax.v1/types"
)

var _ types.SQLType
var _ fmt.Formatter

type modelSaveFunc func(*kallax.Store) error

// NewDistanceExercise returns a new instance of DistanceExercise.
func NewDistanceExercise() (record *DistanceExercise) {
	return new(DistanceExercise)
}

// GetID returns the primary key of the model.
func (r *DistanceExercise) GetID() kallax.Identifier {
	return (*kallax.NumericID)(&r.ID)
}

// ColumnAddress returns the pointer to the value of the given column.
func (r *DistanceExercise) ColumnAddress(col string) (interface{}, error) {
	switch col {
	case "id":
		return (*kallax.NumericID)(&r.ID), nil
	case "time":
		return &r.Time, nil
	case "distance":
		return &r.Distance, nil
	case "units":
		return &r.Units, nil
	case "exercise_id":
		return types.Nullable(kallax.VirtualColumn("exercise_id", r, new(kallax.NumericID))), nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in DistanceExercise: %s", col)
	}
}

// Value returns the value of the given column.
func (r *DistanceExercise) Value(col string) (interface{}, error) {
	switch col {
	case "id":
		return r.ID, nil
	case "time":
		return r.Time, nil
	case "distance":
		return r.Distance, nil
	case "units":
		return r.Units, nil
	case "exercise_id":
		v := r.Model.VirtualColumn(col)
		if v == nil {
			return nil, kallax.ErrEmptyVirtualColumn
		}
		return v, nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in DistanceExercise: %s", col)
	}
}

// NewRelationshipRecord returns a new record for the relatiobship in the given
// field.
func (r *DistanceExercise) NewRelationshipRecord(field string) (kallax.Record, error) {
	return nil, fmt.Errorf("kallax: model DistanceExercise has no relationships")
}

// SetRelationship sets the given relationship in the given field.
func (r *DistanceExercise) SetRelationship(field string, rel interface{}) error {
	return fmt.Errorf("kallax: model DistanceExercise has no relationships")
}

// DistanceExerciseStore is the entity to access the records of the type DistanceExercise
// in the database.
type DistanceExerciseStore struct {
	*kallax.Store
}

// NewDistanceExerciseStore creates a new instance of DistanceExerciseStore
// using a SQL database.
func NewDistanceExerciseStore(db *sql.DB) *DistanceExerciseStore {
	return &DistanceExerciseStore{kallax.NewStore(db)}
}

// GenericStore returns the generic store of this store.
func (s *DistanceExerciseStore) GenericStore() *kallax.Store {
	return s.Store
}

// SetGenericStore changes the generic store of this store.
func (s *DistanceExerciseStore) SetGenericStore(store *kallax.Store) {
	s.Store = store
}

// Debug returns a new store that will print all SQL statements to stdout using
// the log.Printf function.
func (s *DistanceExerciseStore) Debug() *DistanceExerciseStore {
	return &DistanceExerciseStore{s.Store.Debug()}
}

// DebugWith returns a new store that will print all SQL statements using the
// given logger function.
func (s *DistanceExerciseStore) DebugWith(logger kallax.LoggerFunc) *DistanceExerciseStore {
	return &DistanceExerciseStore{s.Store.DebugWith(logger)}
}

// DisableCacher turns off prepared statements, which can be useful in some scenarios.
func (s *DistanceExerciseStore) DisableCacher() *DistanceExerciseStore {
	return &DistanceExerciseStore{s.Store.DisableCacher()}
}

// Insert inserts a DistanceExercise in the database. A non-persisted object is
// required for this operation.
func (s *DistanceExerciseStore) Insert(record *DistanceExercise) error {
	record.SetSaving(true)
	defer record.SetSaving(false)

	return s.Store.Insert(Schema.DistanceExercise.BaseSchema, record)
}

// Update updates the given record on the database. If the columns are given,
// only these columns will be updated. Otherwise all of them will be.
// Be very careful with this, as you will have a potentially different object
// in memory but not on the database.
// Only writable records can be updated. Writable objects are those that have
// been just inserted or retrieved using a query with no custom select fields.
func (s *DistanceExerciseStore) Update(record *DistanceExercise, cols ...kallax.SchemaField) (updated int64, err error) {
	record.SetSaving(true)
	defer record.SetSaving(false)

	return s.Store.Update(Schema.DistanceExercise.BaseSchema, record, cols...)
}

// Save inserts the object if the record is not persisted, otherwise it updates
// it. Same rules of Update and Insert apply depending on the case.
func (s *DistanceExerciseStore) Save(record *DistanceExercise) (updated bool, err error) {
	if !record.IsPersisted() {
		return false, s.Insert(record)
	}

	rowsUpdated, err := s.Update(record)
	if err != nil {
		return false, err
	}

	return rowsUpdated > 0, nil
}

// Delete removes the given record from the database.
func (s *DistanceExerciseStore) Delete(record *DistanceExercise) error {
	return s.Store.Delete(Schema.DistanceExercise.BaseSchema, record)
}

// Find returns the set of results for the given query.
func (s *DistanceExerciseStore) Find(q *DistanceExerciseQuery) (*DistanceExerciseResultSet, error) {
	rs, err := s.Store.Find(q)
	if err != nil {
		return nil, err
	}

	return NewDistanceExerciseResultSet(rs), nil
}

// MustFind returns the set of results for the given query, but panics if there
// is any error.
func (s *DistanceExerciseStore) MustFind(q *DistanceExerciseQuery) *DistanceExerciseResultSet {
	return NewDistanceExerciseResultSet(s.Store.MustFind(q))
}

// Count returns the number of rows that would be retrieved with the given
// query.
func (s *DistanceExerciseStore) Count(q *DistanceExerciseQuery) (int64, error) {
	return s.Store.Count(q)
}

// MustCount returns the number of rows that would be retrieved with the given
// query, but panics if there is an error.
func (s *DistanceExerciseStore) MustCount(q *DistanceExerciseQuery) int64 {
	return s.Store.MustCount(q)
}

// FindOne returns the first row returned by the given query.
// `ErrNotFound` is returned if there are no results.
func (s *DistanceExerciseStore) FindOne(q *DistanceExerciseQuery) (*DistanceExercise, error) {
	q.Limit(1)
	q.Offset(0)
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// FindAll returns a list of all the rows returned by the given query.
func (s *DistanceExerciseStore) FindAll(q *DistanceExerciseQuery) ([]*DistanceExercise, error) {
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	return rs.All()
}

// MustFindOne returns the first row retrieved by the given query. It panics
// if there is an error or if there are no rows.
func (s *DistanceExerciseStore) MustFindOne(q *DistanceExerciseQuery) *DistanceExercise {
	record, err := s.FindOne(q)
	if err != nil {
		panic(err)
	}
	return record
}

// Reload refreshes the DistanceExercise with the data in the database and
// makes it writable.
func (s *DistanceExerciseStore) Reload(record *DistanceExercise) error {
	return s.Store.Reload(Schema.DistanceExercise.BaseSchema, record)
}

// Transaction executes the given callback in a transaction and rollbacks if
// an error is returned.
// The transaction is only open in the store passed as a parameter to the
// callback.
func (s *DistanceExerciseStore) Transaction(callback func(*DistanceExerciseStore) error) error {
	if callback == nil {
		return kallax.ErrInvalidTxCallback
	}

	return s.Store.Transaction(func(store *kallax.Store) error {
		return callback(&DistanceExerciseStore{store})
	})
}

// DistanceExerciseQuery is the object used to create queries for the DistanceExercise
// entity.
type DistanceExerciseQuery struct {
	*kallax.BaseQuery
}

// NewDistanceExerciseQuery returns a new instance of DistanceExerciseQuery.
func NewDistanceExerciseQuery() *DistanceExerciseQuery {
	return &DistanceExerciseQuery{
		BaseQuery: kallax.NewBaseQuery(Schema.DistanceExercise.BaseSchema),
	}
}

// Select adds columns to select in the query.
func (q *DistanceExerciseQuery) Select(columns ...kallax.SchemaField) *DistanceExerciseQuery {
	if len(columns) == 0 {
		return q
	}
	q.BaseQuery.Select(columns...)
	return q
}

// SelectNot excludes columns from being selected in the query.
func (q *DistanceExerciseQuery) SelectNot(columns ...kallax.SchemaField) *DistanceExerciseQuery {
	q.BaseQuery.SelectNot(columns...)
	return q
}

// Copy returns a new identical copy of the query. Remember queries are mutable
// so make a copy any time you need to reuse them.
func (q *DistanceExerciseQuery) Copy() *DistanceExerciseQuery {
	return &DistanceExerciseQuery{
		BaseQuery: q.BaseQuery.Copy(),
	}
}

// Order adds order clauses to the query for the given columns.
func (q *DistanceExerciseQuery) Order(cols ...kallax.ColumnOrder) *DistanceExerciseQuery {
	q.BaseQuery.Order(cols...)
	return q
}

// BatchSize sets the number of items to fetch per batch when there are 1:N
// relationships selected in the query.
func (q *DistanceExerciseQuery) BatchSize(size uint64) *DistanceExerciseQuery {
	q.BaseQuery.BatchSize(size)
	return q
}

// Limit sets the max number of items to retrieve.
func (q *DistanceExerciseQuery) Limit(n uint64) *DistanceExerciseQuery {
	q.BaseQuery.Limit(n)
	return q
}

// Offset sets the number of items to skip from the result set of items.
func (q *DistanceExerciseQuery) Offset(n uint64) *DistanceExerciseQuery {
	q.BaseQuery.Offset(n)
	return q
}

// Where adds a condition to the query. All conditions added are concatenated
// using a logical AND.
func (q *DistanceExerciseQuery) Where(cond kallax.Condition) *DistanceExerciseQuery {
	q.BaseQuery.Where(cond)
	return q
}

// FindByID adds a new filter to the query that will require that
// the ID property is equal to one of the passed values; if no passed values,
// it will do nothing.
func (q *DistanceExerciseQuery) FindByID(v ...int64) *DistanceExerciseQuery {
	if len(v) == 0 {
		return q
	}
	values := make([]interface{}, len(v))
	for i, val := range v {
		values[i] = val
	}
	return q.Where(kallax.In(Schema.DistanceExercise.ID, values...))
}

// FindByTime adds a new filter to the query that will require that
// the Time property is equal to the passed value.
func (q *DistanceExerciseQuery) FindByTime(v string) *DistanceExerciseQuery {
	return q.Where(kallax.Eq(Schema.DistanceExercise.Time, v))
}

// FindByDistance adds a new filter to the query that will require that
// the Distance property is equal to the passed value.
func (q *DistanceExerciseQuery) FindByDistance(cond kallax.ScalarCond, v float32) *DistanceExerciseQuery {
	return q.Where(cond(Schema.DistanceExercise.Distance, v))
}

// FindByUnits adds a new filter to the query that will require that
// the Units property is equal to the passed value.
func (q *DistanceExerciseQuery) FindByUnits(v string) *DistanceExerciseQuery {
	return q.Where(kallax.Eq(Schema.DistanceExercise.Units, v))
}

// DistanceExerciseResultSet is the set of results returned by a query to the
// database.
type DistanceExerciseResultSet struct {
	ResultSet kallax.ResultSet
	last      *DistanceExercise
	lastErr   error
}

// NewDistanceExerciseResultSet creates a new result set for rows of the type
// DistanceExercise.
func NewDistanceExerciseResultSet(rs kallax.ResultSet) *DistanceExerciseResultSet {
	return &DistanceExerciseResultSet{ResultSet: rs}
}

// Next fetches the next item in the result set and returns true if there is
// a next item.
// The result set is closed automatically when there are no more items.
func (rs *DistanceExerciseResultSet) Next() bool {
	if !rs.ResultSet.Next() {
		rs.lastErr = rs.ResultSet.Close()
		rs.last = nil
		return false
	}

	var record kallax.Record
	record, rs.lastErr = rs.ResultSet.Get(Schema.DistanceExercise.BaseSchema)
	if rs.lastErr != nil {
		rs.last = nil
	} else {
		var ok bool
		rs.last, ok = record.(*DistanceExercise)
		if !ok {
			rs.lastErr = fmt.Errorf("kallax: unable to convert record to *DistanceExercise")
			rs.last = nil
		}
	}

	return true
}

// Get retrieves the last fetched item from the result set and the last error.
func (rs *DistanceExerciseResultSet) Get() (*DistanceExercise, error) {
	return rs.last, rs.lastErr
}

// ForEach iterates over the complete result set passing every record found to
// the given callback. It is possible to stop the iteration by returning
// `kallax.ErrStop` in the callback.
// Result set is always closed at the end.
func (rs *DistanceExerciseResultSet) ForEach(fn func(*DistanceExercise) error) error {
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return err
		}

		if err := fn(record); err != nil {
			if err == kallax.ErrStop {
				return rs.Close()
			}

			return err
		}
	}
	return nil
}

// All returns all records on the result set and closes the result set.
func (rs *DistanceExerciseResultSet) All() ([]*DistanceExercise, error) {
	var result []*DistanceExercise
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return nil, err
		}
		result = append(result, record)
	}
	return result, nil
}

// One returns the first record on the result set and closes the result set.
func (rs *DistanceExerciseResultSet) One() (*DistanceExercise, error) {
	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// Err returns the last error occurred.
func (rs *DistanceExerciseResultSet) Err() error {
	return rs.lastErr
}

// Close closes the result set.
func (rs *DistanceExerciseResultSet) Close() error {
	return rs.ResultSet.Close()
}

// NewExercise returns a new instance of Exercise.
func NewExercise() (record *Exercise) {
	return new(Exercise)
}

// GetID returns the primary key of the model.
func (r *Exercise) GetID() kallax.Identifier {
	return (*kallax.NumericID)(&r.ID)
}

// ColumnAddress returns the pointer to the value of the given column.
func (r *Exercise) ColumnAddress(col string) (interface{}, error) {
	switch col {
	case "id":
		return (*kallax.NumericID)(&r.ID), nil
	case "raw":
		return &r.Raw, nil
	case "type":
		return &r.Type, nil
	case "name":
		return &r.Name, nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in Exercise: %s", col)
	}
}

// Value returns the value of the given column.
func (r *Exercise) Value(col string) (interface{}, error) {
	switch col {
	case "id":
		return r.ID, nil
	case "raw":
		return r.Raw, nil
	case "type":
		return r.Type, nil
	case "name":
		return r.Name, nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in Exercise: %s", col)
	}
}

// NewRelationshipRecord returns a new record for the relatiobship in the given
// field.
func (r *Exercise) NewRelationshipRecord(field string) (kallax.Record, error) {
	switch field {
	case "WeightedExercise":
		return new(WeightedExercise), nil
	case "DistanceExercise":
		return new(DistanceExercise), nil

	}
	return nil, fmt.Errorf("kallax: model Exercise has no relationship %s", field)
}

// SetRelationship sets the given relationship in the given field.
func (r *Exercise) SetRelationship(field string, rel interface{}) error {
	switch field {
	case "WeightedExercise":
		val, ok := rel.(*WeightedExercise)
		if !ok {
			return fmt.Errorf("kallax: record of type %t can't be assigned to relationship WeightedExercise", rel)
		}
		if !val.GetID().IsEmpty() {
			r.WeightedExercise = val
		}

		return nil
	case "DistanceExercise":
		val, ok := rel.(*DistanceExercise)
		if !ok {
			return fmt.Errorf("kallax: record of type %t can't be assigned to relationship DistanceExercise", rel)
		}
		if !val.GetID().IsEmpty() {
			r.DistanceExercise = val
		}

		return nil

	}
	return fmt.Errorf("kallax: model Exercise has no relationship %s", field)
}

// ExerciseStore is the entity to access the records of the type Exercise
// in the database.
type ExerciseStore struct {
	*kallax.Store
}

// NewExerciseStore creates a new instance of ExerciseStore
// using a SQL database.
func NewExerciseStore(db *sql.DB) *ExerciseStore {
	return &ExerciseStore{kallax.NewStore(db)}
}

// GenericStore returns the generic store of this store.
func (s *ExerciseStore) GenericStore() *kallax.Store {
	return s.Store
}

// SetGenericStore changes the generic store of this store.
func (s *ExerciseStore) SetGenericStore(store *kallax.Store) {
	s.Store = store
}

// Debug returns a new store that will print all SQL statements to stdout using
// the log.Printf function.
func (s *ExerciseStore) Debug() *ExerciseStore {
	return &ExerciseStore{s.Store.Debug()}
}

// DebugWith returns a new store that will print all SQL statements using the
// given logger function.
func (s *ExerciseStore) DebugWith(logger kallax.LoggerFunc) *ExerciseStore {
	return &ExerciseStore{s.Store.DebugWith(logger)}
}

// DisableCacher turns off prepared statements, which can be useful in some scenarios.
func (s *ExerciseStore) DisableCacher() *ExerciseStore {
	return &ExerciseStore{s.Store.DisableCacher()}
}

func (s *ExerciseStore) relationshipRecords(record *Exercise) []modelSaveFunc {
	var result []modelSaveFunc

	if record.WeightedExercise != nil && !record.WeightedExercise.IsSaving() {
		r := record.WeightedExercise
		r.AddVirtualColumn("exercise_id", record.GetID())
		result = append(result, func(store *kallax.Store) error {
			_, err := (&WeightedExerciseStore{store}).Save(r)
			return err
		})
	}

	if record.DistanceExercise != nil && !record.DistanceExercise.IsSaving() {
		r := record.DistanceExercise
		r.AddVirtualColumn("exercise_id", record.GetID())
		result = append(result, func(store *kallax.Store) error {
			_, err := (&DistanceExerciseStore{store}).Save(r)
			return err
		})
	}

	return result
}

// Insert inserts a Exercise in the database. A non-persisted object is
// required for this operation.
func (s *ExerciseStore) Insert(record *Exercise) error {
	record.SetSaving(true)
	defer record.SetSaving(false)

	records := s.relationshipRecords(record)

	if len(records) > 0 {
		return s.Store.Transaction(func(s *kallax.Store) error {
			if err := s.Insert(Schema.Exercise.BaseSchema, record); err != nil {
				return err
			}

			for _, r := range records {
				if err := r(s); err != nil {
					return err
				}
			}

			return nil
		})
	}

	return s.Store.Insert(Schema.Exercise.BaseSchema, record)
}

// Update updates the given record on the database. If the columns are given,
// only these columns will be updated. Otherwise all of them will be.
// Be very careful with this, as you will have a potentially different object
// in memory but not on the database.
// Only writable records can be updated. Writable objects are those that have
// been just inserted or retrieved using a query with no custom select fields.
func (s *ExerciseStore) Update(record *Exercise, cols ...kallax.SchemaField) (updated int64, err error) {
	record.SetSaving(true)
	defer record.SetSaving(false)

	records := s.relationshipRecords(record)

	if len(records) > 0 {
		err = s.Store.Transaction(func(s *kallax.Store) error {
			updated, err = s.Update(Schema.Exercise.BaseSchema, record, cols...)
			if err != nil {
				return err
			}

			for _, r := range records {
				if err := r(s); err != nil {
					return err
				}
			}

			return nil
		})
		if err != nil {
			return 0, err
		}

		return updated, nil
	}

	return s.Store.Update(Schema.Exercise.BaseSchema, record, cols...)
}

// Save inserts the object if the record is not persisted, otherwise it updates
// it. Same rules of Update and Insert apply depending on the case.
func (s *ExerciseStore) Save(record *Exercise) (updated bool, err error) {
	if !record.IsPersisted() {
		return false, s.Insert(record)
	}

	rowsUpdated, err := s.Update(record)
	if err != nil {
		return false, err
	}

	return rowsUpdated > 0, nil
}

// Delete removes the given record from the database.
func (s *ExerciseStore) Delete(record *Exercise) error {
	return s.Store.Delete(Schema.Exercise.BaseSchema, record)
}

// Find returns the set of results for the given query.
func (s *ExerciseStore) Find(q *ExerciseQuery) (*ExerciseResultSet, error) {
	rs, err := s.Store.Find(q)
	if err != nil {
		return nil, err
	}

	return NewExerciseResultSet(rs), nil
}

// MustFind returns the set of results for the given query, but panics if there
// is any error.
func (s *ExerciseStore) MustFind(q *ExerciseQuery) *ExerciseResultSet {
	return NewExerciseResultSet(s.Store.MustFind(q))
}

// Count returns the number of rows that would be retrieved with the given
// query.
func (s *ExerciseStore) Count(q *ExerciseQuery) (int64, error) {
	return s.Store.Count(q)
}

// MustCount returns the number of rows that would be retrieved with the given
// query, but panics if there is an error.
func (s *ExerciseStore) MustCount(q *ExerciseQuery) int64 {
	return s.Store.MustCount(q)
}

// FindOne returns the first row returned by the given query.
// `ErrNotFound` is returned if there are no results.
func (s *ExerciseStore) FindOne(q *ExerciseQuery) (*Exercise, error) {
	q.Limit(1)
	q.Offset(0)
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// FindAll returns a list of all the rows returned by the given query.
func (s *ExerciseStore) FindAll(q *ExerciseQuery) ([]*Exercise, error) {
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	return rs.All()
}

// MustFindOne returns the first row retrieved by the given query. It panics
// if there is an error or if there are no rows.
func (s *ExerciseStore) MustFindOne(q *ExerciseQuery) *Exercise {
	record, err := s.FindOne(q)
	if err != nil {
		panic(err)
	}
	return record
}

// Reload refreshes the Exercise with the data in the database and
// makes it writable.
func (s *ExerciseStore) Reload(record *Exercise) error {
	return s.Store.Reload(Schema.Exercise.BaseSchema, record)
}

// Transaction executes the given callback in a transaction and rollbacks if
// an error is returned.
// The transaction is only open in the store passed as a parameter to the
// callback.
func (s *ExerciseStore) Transaction(callback func(*ExerciseStore) error) error {
	if callback == nil {
		return kallax.ErrInvalidTxCallback
	}

	return s.Store.Transaction(func(store *kallax.Store) error {
		return callback(&ExerciseStore{store})
	})
}

// RemoveWeightedExercise removes from the database the given relationship of the
// model. It also resets the field WeightedExercise of the model.
func (s *ExerciseStore) RemoveWeightedExercise(record *Exercise) error {
	var r kallax.Record = record.WeightedExercise
	if beforeDeleter, ok := r.(kallax.BeforeDeleter); ok {
		if err := beforeDeleter.BeforeDelete(); err != nil {
			return err
		}
	}

	var err error
	if afterDeleter, ok := r.(kallax.AfterDeleter); ok {
		err = s.Store.Transaction(func(s *kallax.Store) error {
			err := s.Delete(Schema.WeightedExercise.BaseSchema, r)
			if err != nil {
				return err
			}

			return afterDeleter.AfterDelete()
		})
	} else {
		err = s.Store.Delete(Schema.WeightedExercise.BaseSchema, r)
	}
	if err != nil {
		return err
	}

	record.WeightedExercise = nil
	return nil
}

// RemoveDistanceExercise removes from the database the given relationship of the
// model. It also resets the field DistanceExercise of the model.
func (s *ExerciseStore) RemoveDistanceExercise(record *Exercise) error {
	var r kallax.Record = record.DistanceExercise
	if beforeDeleter, ok := r.(kallax.BeforeDeleter); ok {
		if err := beforeDeleter.BeforeDelete(); err != nil {
			return err
		}
	}

	var err error
	if afterDeleter, ok := r.(kallax.AfterDeleter); ok {
		err = s.Store.Transaction(func(s *kallax.Store) error {
			err := s.Delete(Schema.DistanceExercise.BaseSchema, r)
			if err != nil {
				return err
			}

			return afterDeleter.AfterDelete()
		})
	} else {
		err = s.Store.Delete(Schema.DistanceExercise.BaseSchema, r)
	}
	if err != nil {
		return err
	}

	record.DistanceExercise = nil
	return nil
}

// ExerciseQuery is the object used to create queries for the Exercise
// entity.
type ExerciseQuery struct {
	*kallax.BaseQuery
}

// NewExerciseQuery returns a new instance of ExerciseQuery.
func NewExerciseQuery() *ExerciseQuery {
	return &ExerciseQuery{
		BaseQuery: kallax.NewBaseQuery(Schema.Exercise.BaseSchema),
	}
}

// Select adds columns to select in the query.
func (q *ExerciseQuery) Select(columns ...kallax.SchemaField) *ExerciseQuery {
	if len(columns) == 0 {
		return q
	}
	q.BaseQuery.Select(columns...)
	return q
}

// SelectNot excludes columns from being selected in the query.
func (q *ExerciseQuery) SelectNot(columns ...kallax.SchemaField) *ExerciseQuery {
	q.BaseQuery.SelectNot(columns...)
	return q
}

// Copy returns a new identical copy of the query. Remember queries are mutable
// so make a copy any time you need to reuse them.
func (q *ExerciseQuery) Copy() *ExerciseQuery {
	return &ExerciseQuery{
		BaseQuery: q.BaseQuery.Copy(),
	}
}

// Order adds order clauses to the query for the given columns.
func (q *ExerciseQuery) Order(cols ...kallax.ColumnOrder) *ExerciseQuery {
	q.BaseQuery.Order(cols...)
	return q
}

// BatchSize sets the number of items to fetch per batch when there are 1:N
// relationships selected in the query.
func (q *ExerciseQuery) BatchSize(size uint64) *ExerciseQuery {
	q.BaseQuery.BatchSize(size)
	return q
}

// Limit sets the max number of items to retrieve.
func (q *ExerciseQuery) Limit(n uint64) *ExerciseQuery {
	q.BaseQuery.Limit(n)
	return q
}

// Offset sets the number of items to skip from the result set of items.
func (q *ExerciseQuery) Offset(n uint64) *ExerciseQuery {
	q.BaseQuery.Offset(n)
	return q
}

// Where adds a condition to the query. All conditions added are concatenated
// using a logical AND.
func (q *ExerciseQuery) Where(cond kallax.Condition) *ExerciseQuery {
	q.BaseQuery.Where(cond)
	return q
}

func (q *ExerciseQuery) WithWeightedExercise() *ExerciseQuery {
	q.AddRelation(Schema.WeightedExercise.BaseSchema, "WeightedExercise", kallax.OneToOne, nil)
	return q
}

func (q *ExerciseQuery) WithDistanceExercise() *ExerciseQuery {
	q.AddRelation(Schema.DistanceExercise.BaseSchema, "DistanceExercise", kallax.OneToOne, nil)
	return q
}

// FindByID adds a new filter to the query that will require that
// the ID property is equal to one of the passed values; if no passed values,
// it will do nothing.
func (q *ExerciseQuery) FindByID(v ...int64) *ExerciseQuery {
	if len(v) == 0 {
		return q
	}
	values := make([]interface{}, len(v))
	for i, val := range v {
		values[i] = val
	}
	return q.Where(kallax.In(Schema.Exercise.ID, values...))
}

// FindByRaw adds a new filter to the query that will require that
// the Raw property is equal to the passed value.
func (q *ExerciseQuery) FindByRaw(v string) *ExerciseQuery {
	return q.Where(kallax.Eq(Schema.Exercise.Raw, v))
}

// FindByType adds a new filter to the query that will require that
// the Type property is equal to the passed value.
func (q *ExerciseQuery) FindByType(v string) *ExerciseQuery {
	return q.Where(kallax.Eq(Schema.Exercise.Type, v))
}

// FindByName adds a new filter to the query that will require that
// the Name property is equal to the passed value.
func (q *ExerciseQuery) FindByName(v string) *ExerciseQuery {
	return q.Where(kallax.Eq(Schema.Exercise.Name, v))
}

// ExerciseResultSet is the set of results returned by a query to the
// database.
type ExerciseResultSet struct {
	ResultSet kallax.ResultSet
	last      *Exercise
	lastErr   error
}

// NewExerciseResultSet creates a new result set for rows of the type
// Exercise.
func NewExerciseResultSet(rs kallax.ResultSet) *ExerciseResultSet {
	return &ExerciseResultSet{ResultSet: rs}
}

// Next fetches the next item in the result set and returns true if there is
// a next item.
// The result set is closed automatically when there are no more items.
func (rs *ExerciseResultSet) Next() bool {
	if !rs.ResultSet.Next() {
		rs.lastErr = rs.ResultSet.Close()
		rs.last = nil
		return false
	}

	var record kallax.Record
	record, rs.lastErr = rs.ResultSet.Get(Schema.Exercise.BaseSchema)
	if rs.lastErr != nil {
		rs.last = nil
	} else {
		var ok bool
		rs.last, ok = record.(*Exercise)
		if !ok {
			rs.lastErr = fmt.Errorf("kallax: unable to convert record to *Exercise")
			rs.last = nil
		}
	}

	return true
}

// Get retrieves the last fetched item from the result set and the last error.
func (rs *ExerciseResultSet) Get() (*Exercise, error) {
	return rs.last, rs.lastErr
}

// ForEach iterates over the complete result set passing every record found to
// the given callback. It is possible to stop the iteration by returning
// `kallax.ErrStop` in the callback.
// Result set is always closed at the end.
func (rs *ExerciseResultSet) ForEach(fn func(*Exercise) error) error {
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return err
		}

		if err := fn(record); err != nil {
			if err == kallax.ErrStop {
				return rs.Close()
			}

			return err
		}
	}
	return nil
}

// All returns all records on the result set and closes the result set.
func (rs *ExerciseResultSet) All() ([]*Exercise, error) {
	var result []*Exercise
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return nil, err
		}
		result = append(result, record)
	}
	return result, nil
}

// One returns the first record on the result set and closes the result set.
func (rs *ExerciseResultSet) One() (*Exercise, error) {
	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// Err returns the last error occurred.
func (rs *ExerciseResultSet) Err() error {
	return rs.lastErr
}

// Close closes the result set.
func (rs *ExerciseResultSet) Close() error {
	return rs.ResultSet.Close()
}

// NewWeightedExercise returns a new instance of WeightedExercise.
func NewWeightedExercise() (record *WeightedExercise) {
	return new(WeightedExercise)
}

// GetID returns the primary key of the model.
func (r *WeightedExercise) GetID() kallax.Identifier {
	return (*kallax.NumericID)(&r.ID)
}

// ColumnAddress returns the pointer to the value of the given column.
func (r *WeightedExercise) ColumnAddress(col string) (interface{}, error) {
	switch col {
	case "id":
		return (*kallax.NumericID)(&r.ID), nil
	case "sets":
		return &r.Sets, nil
	case "reps":
		return &r.Reps, nil
	case "exercise_id":
		return types.Nullable(kallax.VirtualColumn("exercise_id", r, new(kallax.NumericID))), nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in WeightedExercise: %s", col)
	}
}

// Value returns the value of the given column.
func (r *WeightedExercise) Value(col string) (interface{}, error) {
	switch col {
	case "id":
		return r.ID, nil
	case "sets":
		return r.Sets, nil
	case "reps":
		return r.Reps, nil
	case "exercise_id":
		v := r.Model.VirtualColumn(col)
		if v == nil {
			return nil, kallax.ErrEmptyVirtualColumn
		}
		return v, nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in WeightedExercise: %s", col)
	}
}

// NewRelationshipRecord returns a new record for the relatiobship in the given
// field.
func (r *WeightedExercise) NewRelationshipRecord(field string) (kallax.Record, error) {
	return nil, fmt.Errorf("kallax: model WeightedExercise has no relationships")
}

// SetRelationship sets the given relationship in the given field.
func (r *WeightedExercise) SetRelationship(field string, rel interface{}) error {
	return fmt.Errorf("kallax: model WeightedExercise has no relationships")
}

// WeightedExerciseStore is the entity to access the records of the type WeightedExercise
// in the database.
type WeightedExerciseStore struct {
	*kallax.Store
}

// NewWeightedExerciseStore creates a new instance of WeightedExerciseStore
// using a SQL database.
func NewWeightedExerciseStore(db *sql.DB) *WeightedExerciseStore {
	return &WeightedExerciseStore{kallax.NewStore(db)}
}

// GenericStore returns the generic store of this store.
func (s *WeightedExerciseStore) GenericStore() *kallax.Store {
	return s.Store
}

// SetGenericStore changes the generic store of this store.
func (s *WeightedExerciseStore) SetGenericStore(store *kallax.Store) {
	s.Store = store
}

// Debug returns a new store that will print all SQL statements to stdout using
// the log.Printf function.
func (s *WeightedExerciseStore) Debug() *WeightedExerciseStore {
	return &WeightedExerciseStore{s.Store.Debug()}
}

// DebugWith returns a new store that will print all SQL statements using the
// given logger function.
func (s *WeightedExerciseStore) DebugWith(logger kallax.LoggerFunc) *WeightedExerciseStore {
	return &WeightedExerciseStore{s.Store.DebugWith(logger)}
}

// DisableCacher turns off prepared statements, which can be useful in some scenarios.
func (s *WeightedExerciseStore) DisableCacher() *WeightedExerciseStore {
	return &WeightedExerciseStore{s.Store.DisableCacher()}
}

// Insert inserts a WeightedExercise in the database. A non-persisted object is
// required for this operation.
func (s *WeightedExerciseStore) Insert(record *WeightedExercise) error {
	record.SetSaving(true)
	defer record.SetSaving(false)

	return s.Store.Insert(Schema.WeightedExercise.BaseSchema, record)
}

// Update updates the given record on the database. If the columns are given,
// only these columns will be updated. Otherwise all of them will be.
// Be very careful with this, as you will have a potentially different object
// in memory but not on the database.
// Only writable records can be updated. Writable objects are those that have
// been just inserted or retrieved using a query with no custom select fields.
func (s *WeightedExerciseStore) Update(record *WeightedExercise, cols ...kallax.SchemaField) (updated int64, err error) {
	record.SetSaving(true)
	defer record.SetSaving(false)

	return s.Store.Update(Schema.WeightedExercise.BaseSchema, record, cols...)
}

// Save inserts the object if the record is not persisted, otherwise it updates
// it. Same rules of Update and Insert apply depending on the case.
func (s *WeightedExerciseStore) Save(record *WeightedExercise) (updated bool, err error) {
	if !record.IsPersisted() {
		return false, s.Insert(record)
	}

	rowsUpdated, err := s.Update(record)
	if err != nil {
		return false, err
	}

	return rowsUpdated > 0, nil
}

// Delete removes the given record from the database.
func (s *WeightedExerciseStore) Delete(record *WeightedExercise) error {
	return s.Store.Delete(Schema.WeightedExercise.BaseSchema, record)
}

// Find returns the set of results for the given query.
func (s *WeightedExerciseStore) Find(q *WeightedExerciseQuery) (*WeightedExerciseResultSet, error) {
	rs, err := s.Store.Find(q)
	if err != nil {
		return nil, err
	}

	return NewWeightedExerciseResultSet(rs), nil
}

// MustFind returns the set of results for the given query, but panics if there
// is any error.
func (s *WeightedExerciseStore) MustFind(q *WeightedExerciseQuery) *WeightedExerciseResultSet {
	return NewWeightedExerciseResultSet(s.Store.MustFind(q))
}

// Count returns the number of rows that would be retrieved with the given
// query.
func (s *WeightedExerciseStore) Count(q *WeightedExerciseQuery) (int64, error) {
	return s.Store.Count(q)
}

// MustCount returns the number of rows that would be retrieved with the given
// query, but panics if there is an error.
func (s *WeightedExerciseStore) MustCount(q *WeightedExerciseQuery) int64 {
	return s.Store.MustCount(q)
}

// FindOne returns the first row returned by the given query.
// `ErrNotFound` is returned if there are no results.
func (s *WeightedExerciseStore) FindOne(q *WeightedExerciseQuery) (*WeightedExercise, error) {
	q.Limit(1)
	q.Offset(0)
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// FindAll returns a list of all the rows returned by the given query.
func (s *WeightedExerciseStore) FindAll(q *WeightedExerciseQuery) ([]*WeightedExercise, error) {
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	return rs.All()
}

// MustFindOne returns the first row retrieved by the given query. It panics
// if there is an error or if there are no rows.
func (s *WeightedExerciseStore) MustFindOne(q *WeightedExerciseQuery) *WeightedExercise {
	record, err := s.FindOne(q)
	if err != nil {
		panic(err)
	}
	return record
}

// Reload refreshes the WeightedExercise with the data in the database and
// makes it writable.
func (s *WeightedExerciseStore) Reload(record *WeightedExercise) error {
	return s.Store.Reload(Schema.WeightedExercise.BaseSchema, record)
}

// Transaction executes the given callback in a transaction and rollbacks if
// an error is returned.
// The transaction is only open in the store passed as a parameter to the
// callback.
func (s *WeightedExerciseStore) Transaction(callback func(*WeightedExerciseStore) error) error {
	if callback == nil {
		return kallax.ErrInvalidTxCallback
	}

	return s.Store.Transaction(func(store *kallax.Store) error {
		return callback(&WeightedExerciseStore{store})
	})
}

// WeightedExerciseQuery is the object used to create queries for the WeightedExercise
// entity.
type WeightedExerciseQuery struct {
	*kallax.BaseQuery
}

// NewWeightedExerciseQuery returns a new instance of WeightedExerciseQuery.
func NewWeightedExerciseQuery() *WeightedExerciseQuery {
	return &WeightedExerciseQuery{
		BaseQuery: kallax.NewBaseQuery(Schema.WeightedExercise.BaseSchema),
	}
}

// Select adds columns to select in the query.
func (q *WeightedExerciseQuery) Select(columns ...kallax.SchemaField) *WeightedExerciseQuery {
	if len(columns) == 0 {
		return q
	}
	q.BaseQuery.Select(columns...)
	return q
}

// SelectNot excludes columns from being selected in the query.
func (q *WeightedExerciseQuery) SelectNot(columns ...kallax.SchemaField) *WeightedExerciseQuery {
	q.BaseQuery.SelectNot(columns...)
	return q
}

// Copy returns a new identical copy of the query. Remember queries are mutable
// so make a copy any time you need to reuse them.
func (q *WeightedExerciseQuery) Copy() *WeightedExerciseQuery {
	return &WeightedExerciseQuery{
		BaseQuery: q.BaseQuery.Copy(),
	}
}

// Order adds order clauses to the query for the given columns.
func (q *WeightedExerciseQuery) Order(cols ...kallax.ColumnOrder) *WeightedExerciseQuery {
	q.BaseQuery.Order(cols...)
	return q
}

// BatchSize sets the number of items to fetch per batch when there are 1:N
// relationships selected in the query.
func (q *WeightedExerciseQuery) BatchSize(size uint64) *WeightedExerciseQuery {
	q.BaseQuery.BatchSize(size)
	return q
}

// Limit sets the max number of items to retrieve.
func (q *WeightedExerciseQuery) Limit(n uint64) *WeightedExerciseQuery {
	q.BaseQuery.Limit(n)
	return q
}

// Offset sets the number of items to skip from the result set of items.
func (q *WeightedExerciseQuery) Offset(n uint64) *WeightedExerciseQuery {
	q.BaseQuery.Offset(n)
	return q
}

// Where adds a condition to the query. All conditions added are concatenated
// using a logical AND.
func (q *WeightedExerciseQuery) Where(cond kallax.Condition) *WeightedExerciseQuery {
	q.BaseQuery.Where(cond)
	return q
}

// FindByID adds a new filter to the query that will require that
// the ID property is equal to one of the passed values; if no passed values,
// it will do nothing.
func (q *WeightedExerciseQuery) FindByID(v ...int64) *WeightedExerciseQuery {
	if len(v) == 0 {
		return q
	}
	values := make([]interface{}, len(v))
	for i, val := range v {
		values[i] = val
	}
	return q.Where(kallax.In(Schema.WeightedExercise.ID, values...))
}

// FindBySets adds a new filter to the query that will require that
// the Sets property is equal to the passed value.
func (q *WeightedExerciseQuery) FindBySets(cond kallax.ScalarCond, v int) *WeightedExerciseQuery {
	return q.Where(cond(Schema.WeightedExercise.Sets, v))
}

// FindByReps adds a new filter to the query that will require that
// the Reps property is equal to the passed value.
func (q *WeightedExerciseQuery) FindByReps(cond kallax.ScalarCond, v int) *WeightedExerciseQuery {
	return q.Where(cond(Schema.WeightedExercise.Reps, v))
}

// WeightedExerciseResultSet is the set of results returned by a query to the
// database.
type WeightedExerciseResultSet struct {
	ResultSet kallax.ResultSet
	last      *WeightedExercise
	lastErr   error
}

// NewWeightedExerciseResultSet creates a new result set for rows of the type
// WeightedExercise.
func NewWeightedExerciseResultSet(rs kallax.ResultSet) *WeightedExerciseResultSet {
	return &WeightedExerciseResultSet{ResultSet: rs}
}

// Next fetches the next item in the result set and returns true if there is
// a next item.
// The result set is closed automatically when there are no more items.
func (rs *WeightedExerciseResultSet) Next() bool {
	if !rs.ResultSet.Next() {
		rs.lastErr = rs.ResultSet.Close()
		rs.last = nil
		return false
	}

	var record kallax.Record
	record, rs.lastErr = rs.ResultSet.Get(Schema.WeightedExercise.BaseSchema)
	if rs.lastErr != nil {
		rs.last = nil
	} else {
		var ok bool
		rs.last, ok = record.(*WeightedExercise)
		if !ok {
			rs.lastErr = fmt.Errorf("kallax: unable to convert record to *WeightedExercise")
			rs.last = nil
		}
	}

	return true
}

// Get retrieves the last fetched item from the result set and the last error.
func (rs *WeightedExerciseResultSet) Get() (*WeightedExercise, error) {
	return rs.last, rs.lastErr
}

// ForEach iterates over the complete result set passing every record found to
// the given callback. It is possible to stop the iteration by returning
// `kallax.ErrStop` in the callback.
// Result set is always closed at the end.
func (rs *WeightedExerciseResultSet) ForEach(fn func(*WeightedExercise) error) error {
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return err
		}

		if err := fn(record); err != nil {
			if err == kallax.ErrStop {
				return rs.Close()
			}

			return err
		}
	}
	return nil
}

// All returns all records on the result set and closes the result set.
func (rs *WeightedExerciseResultSet) All() ([]*WeightedExercise, error) {
	var result []*WeightedExercise
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return nil, err
		}
		result = append(result, record)
	}
	return result, nil
}

// One returns the first record on the result set and closes the result set.
func (rs *WeightedExerciseResultSet) One() (*WeightedExercise, error) {
	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// Err returns the last error occurred.
func (rs *WeightedExerciseResultSet) Err() error {
	return rs.lastErr
}

// Close closes the result set.
func (rs *WeightedExerciseResultSet) Close() error {
	return rs.ResultSet.Close()
}

type schema struct {
	DistanceExercise *schemaDistanceExercise
	Exercise         *schemaExercise
	WeightedExercise *schemaWeightedExercise
}

type schemaDistanceExercise struct {
	*kallax.BaseSchema
	ID       kallax.SchemaField
	Time     kallax.SchemaField
	Distance kallax.SchemaField
	Units    kallax.SchemaField
}

type schemaExercise struct {
	*kallax.BaseSchema
	ID   kallax.SchemaField
	Raw  kallax.SchemaField
	Type kallax.SchemaField
	Name kallax.SchemaField
}

type schemaWeightedExercise struct {
	*kallax.BaseSchema
	ID   kallax.SchemaField
	Sets kallax.SchemaField
	Reps kallax.SchemaField
}

var Schema = &schema{
	DistanceExercise: &schemaDistanceExercise{
		BaseSchema: kallax.NewBaseSchema(
			"distance_exercise",
			"__distanceexercise",
			kallax.NewSchemaField("id"),
			kallax.ForeignKeys{},
			func() kallax.Record {
				return new(DistanceExercise)
			},
			true,
			kallax.NewSchemaField("id"),
			kallax.NewSchemaField("time"),
			kallax.NewSchemaField("distance"),
			kallax.NewSchemaField("units"),
			kallax.NewSchemaField("exercise_id"),
		),
		ID:       kallax.NewSchemaField("id"),
		Time:     kallax.NewSchemaField("time"),
		Distance: kallax.NewSchemaField("distance"),
		Units:    kallax.NewSchemaField("units"),
	},
	Exercise: &schemaExercise{
		BaseSchema: kallax.NewBaseSchema(
			"exercises",
			"__exercise",
			kallax.NewSchemaField("id"),
			kallax.ForeignKeys{
				"WeightedExercise": kallax.NewForeignKey("exercise_id", false),
				"DistanceExercise": kallax.NewForeignKey("exercise_id", false),
			},
			func() kallax.Record {
				return new(Exercise)
			},
			true,
			kallax.NewSchemaField("id"),
			kallax.NewSchemaField("raw"),
			kallax.NewSchemaField("type"),
			kallax.NewSchemaField("name"),
		),
		ID:   kallax.NewSchemaField("id"),
		Raw:  kallax.NewSchemaField("raw"),
		Type: kallax.NewSchemaField("type"),
		Name: kallax.NewSchemaField("name"),
	},
	WeightedExercise: &schemaWeightedExercise{
		BaseSchema: kallax.NewBaseSchema(
			"weighted_exercises",
			"__weightedexercise",
			kallax.NewSchemaField("id"),
			kallax.ForeignKeys{},
			func() kallax.Record {
				return new(WeightedExercise)
			},
			true,
			kallax.NewSchemaField("id"),
			kallax.NewSchemaField("sets"),
			kallax.NewSchemaField("reps"),
			kallax.NewSchemaField("exercise_id"),
		),
		ID:   kallax.NewSchemaField("id"),
		Sets: kallax.NewSchemaField("sets"),
		Reps: kallax.NewSchemaField("reps"),
	},
}
